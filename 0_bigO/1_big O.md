# big O

### big O의 개념

---

- big O시간 = 알고리즘의 효율성을 나타내는 지표 또는 언어

(예) 데이터 전송 알고리즘
O(s) : 파일의 크기가 s일 때, 파일 크기가 증가함에 따라 전송시간이 선형적으로 증가
O(1) : 파일 크기에 상관없이 상수시간 만큼만 소요

### 시간 복잡도

---

- 알고리즘의 수행시간은 **3가지 방법**으로 나타낼 수 있음
    1. 최선의 경우

        \$O(N)\$

    2. 최악의 경우

        $$O(N^2)$$

    3. 평균의 경우

    $$O(NlogN)$$

### 공간 복잡도

---

- 알고리즘에서는 시간 외에도 **메모리(공간)**을 고려해야 함

- 크기가 n인 배열을 생성 ⇒ O(n)의 공간이 필요
- n x n 크기의 2차원 배열을 생성 ⇒ O(n^2)의 공간 필요

- 재귀 호출에서 사용되는 스택 공간은 공간 복잡도 계산에 사용됨

Case 1

```c
int sum(int n) {
	if (n <= 0){
		return 0;
	}
	return n + sum(n-1);
}

// sum함수가 호출될 때마다 스택의 깊이가 깊어짐
// 위의 호출은 전부 호출 스택에 더해지고, 실제 메모리 공간을 잡아 먹음
```

Case 2

```c
int pairSumSequence(int n){
	int sum=0;
	for(int i=0; i<n; i++){
		sum+=pairSum(i, i+1);
	}
	return sum;
}

int pairSum(int a, int b){
	return a+b;
}

// pairSum 함수를 대략 O(n)번 호출하지만, 함수들이 호출 스택에 동시에 존재하지 않음
// O(1) 공간만 사용
```

### 상수항은 무시하기

---

- 시간 복잡도에서, O(N)이 항상 O(2N)보다 좋은 것은 아니다.

(1) for문을 한번 호출 (2) for문을 두 번 호출

```c
int min = Integer.MAX_VALUE;
int max = Integer.Min_VALUE;

//CASE 1
for(int x : array) {
	if (x<min) min=x;
	if (x<max) max=x;
}

//CASE 2
for(int x : array) {
	if (x<min) min=x;
}
for(int x : array) {
	if (x>max) max=x;
}
```

### 지배적이지 않은 항은 무시하기

---

$$O(N^2+N) = O(N^2)$$

$$O(N+logN) = O(N)$$

$$O(5*2^N+1000N^100) = O(2^N)$$

### 여러 부분으로 이루어진 알고리즘 : 덧셈, 곱셈

---

- 알고리즘이 두 단계로 이루어질 때, 어떤 경우에 **수행시간을 더하고** 어떤 경우에 **수행시간을 더할까**?

덧셈과 곱셈

```c
// 덧셈 수행시간 : O(A+B)
for (int a : arrA){
	print(a);
}
for (int b : arrB){
	print(b);
}

// 곱셈 수행시간 : O(A*B)
for (int a : arrA){
	for (int b : arrB){
		print(a + "," + b);
	}
}
```

A **일을 모두 끝마친 뒤에** B를 수행하라 ⇒ **A + B**
A **일을 할 때 마다**, B 일을 수행하라 ⇒ **A * B**

### 상환시간

---

- **ArrayList (동적 가변크기 배열)**
    - 배열의 역할을 하고, 동시에 크기가 자유롭게 조절되는 자료구조 (배열로 구현됨)
    - 원소 삽입 시 필요에 따라 배열의 크기를 증가시킬 수 있어, 배열의 공간이 바닥날 일은 없음
    - 기존보다 크기가 2배 더 큰 배열을 만든 뒤, 이전 배열의 모든 원소를 새 배열로 복사
- 전체 수행 시간의 계산
    1. 배열이 가득찬 경우(N개), 새로운 원소를 삽입하려면 O(N)시간이 소요
    2. 대다수의 경우에는 배열이 가득 차지 않은 경우로, 이때의 삽입 연산은 O(1) 시간이 소요

    **상환 개념**을 이용하여 계산
    ⇒ 최악의 경우(배열이 가득 찬 경우)는 가끔 발생하지만, 한 번 발생하면 그 후로 꽤 오랫동안 나타나지 않으므로 비용(수행시간)을 분할 상환한다.